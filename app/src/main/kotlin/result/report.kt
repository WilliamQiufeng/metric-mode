package org.example.app.result

import ai.koog.prompt.dsl.prompt
import ai.koog.prompt.executor.clients.openai.OpenAIModels
import ai.koog.prompt.executor.model.PromptExecutor
import ai.koog.prompt.structure.StructureFixingParser
import ai.koog.prompt.structure.executeStructured
import kotlinx.serialization.Serializable
import kotlinx.serialization.json.JsonObject
import org.example.app.core.MlAutoGenCore
import java.io.ByteArrayOutputStream
import java.nio.charset.StandardCharsets
import java.nio.file.Files
import java.nio.file.Path
import kotlin.io.path.exists
import kotlin.io.path.readText
import kotlin.io.path.writeText

/**
 * report.kt
 *
 * Generates a detailed report based on:
 * - model.py
 * - final_test.py output (stdout + optional JSON)
 *
 * Outputs:
 * - workDir/report.md
 * - workDir/report.pdf  (generated by a tiny, dependency-free PDF writer)
 *
 * Note:
 * - The tiny PDF writer is ASCII-first; it will replace non-ASCII chars with '?'.
 * - Therefore the LLM is instructed to write the report in English by default.
 */
class ReportGenerator(
    private val executor: PromptExecutor,
    private val llmModel: ai.koog.prompt.llm.LLModel = OpenAIModels.Chat.GPT4oMini,
    private val fixerModel: ai.koog.prompt.llm.LLModel = OpenAIModels.Chat.GPT4o
) {

    @Serializable
    data class ReportDoc(
        val title: String,
        val executiveSummary: String,
        val taskSpec: String,
        val modelOverview: String,
        val dataPipeline: String,
        val trainingAndInference: String,
        val evaluation: String,
        val metrics: List<MetricItem>,
        val interpretability: String,
        val failureModesAndLimitations: List<String>,
        val recommendedNextSteps: List<String>,
        val reproducibility: List<String>,
        val appendixNotes: String
    ) {
        @Serializable
        data class MetricItem(
            val name: String,
            val value: String,
            val notes: String
        )
    }

    data class ReportArtifacts(
        val markdownPath: Path,
        val pdfPath: Path
    )

    suspend fun generate(
        workDir: Path,
        spec: MlAutoGenCore.ChecklistSpec,
        finalTestStdout: String,
        finalTestJson: JsonObject? = null,
        contract: String = MlAutoGenCore.MODEL_API_CONTRACT,
        outMarkdown: String = "report.md",
        outPdf: String = "report.pdf"
    ): ReportArtifacts {
        val modelPath = workDir.resolve("model.py")
        require(modelPath.exists()) { "model.py not found at: $modelPath" }

        val modelPy = modelPath.readText()
        val modelPreview = ResultIo.truncateForPrompt(
            ResultIo.smartPreview(modelPy, headChars = 6000, tailChars = 2500),
            maxChars = 9000
        )

        val fixingParser = StructureFixingParser(model = fixerModel, retries = 2)

        val p = prompt("generate-detailed-report") {
            system(
                """
You are a senior ML engineer writing a detailed technical report for stakeholders.

Output ONLY valid JSON following the schema ReportDoc.
No markdown fences. No extra commentary.

Constraints:
- Be consistent with the given task spec + contract + model.py preview.
- Use final_test stdout + JSON (if provided) for evaluation/metrics.
- Keep it detailed but not overly long.
- Write in English (PDF writer is ASCII-first).
                """.trimIndent()
            )
            user(
                """
Task spec:
- inputType = ${spec.inputType}
- outputType = ${spec.outputType}
- trainingType = ${spec.trainingType}
- splitStrategy = ${spec.splitStrategy}
- metric = ${spec.metric}
- dataPath = ${spec.dataPath}

Model API contract:
$contract

model.py preview (may be truncated):
$modelPreview

final_test stdout:
${ResultIo.truncateForPrompt(finalTestStdout, 8000)}

final_test JSON (if any):
${finalTestJson?.toString() ?: "null"}
                """.trimIndent()
            )
        }

        val report = executor.executeStructured<ReportDoc>(
            prompt = p,
            model = llmModel,
            fixingParser = fixingParser
        ).getOrThrow().data

        val md = renderMarkdown(report)
        val mdPath = workDir.resolve(outMarkdown)
        mdPath.writeText(md)

        val pdfPath = workDir.resolve(outPdf)
        TinyPdfWriter().write(
            title = report.title,
            markdown = md,
            outFile = pdfPath
        )

        return ReportArtifacts(markdownPath = mdPath, pdfPath = pdfPath)
    }

    private fun renderMarkdown(doc: ReportDoc): String = buildString {
        appendLine("# ${doc.title}".trim())
        appendLine()
        appendLine("## Executive summary")
        appendLine(doc.executiveSummary.trim())
        appendLine()
        appendLine("## Task specification")
        appendLine(doc.taskSpec.trim())
        appendLine()
        appendLine("## Model overview")
        appendLine(doc.modelOverview.trim())
        appendLine()
        appendLine("## Data pipeline")
        appendLine(doc.dataPipeline.trim())
        appendLine()
        appendLine("## Training and inference")
        appendLine(doc.trainingAndInference.trim())
        appendLine()
        appendLine("## Evaluation")
        appendLine(doc.evaluation.trim())
        appendLine()
        appendLine("## Metrics")
        if (doc.metrics.isEmpty()) {
            appendLine("- (No metrics reported)")
        } else {
            doc.metrics.forEach {
                appendLine("- **${it.name}**: ${it.value} â€” ${it.notes}".trim())
            }
        }
        appendLine()
        appendLine("## Interpretability and model expression")
        appendLine(doc.interpretability.trim())
        appendLine()
        appendLine("## Failure modes and limitations")
        doc.failureModesAndLimitations.forEach { appendLine("- ${it.trim()}") }
        appendLine()
        appendLine("## Recommended next steps")
        doc.recommendedNextSteps.forEach { appendLine("- ${it.trim()}") }
        appendLine()
        appendLine("## Reproducibility checklist")
        doc.reproducibility.forEach { appendLine("- ${it.trim()}") }
        appendLine()
        appendLine("## Appendix")
        appendLine(doc.appendixNotes.trim())
        appendLine()
    }
}

/**
 * A tiny, dependency-free PDF writer.
 *
 * - Creates a simple multi-page PDF with Helvetica Type1 font.
 * - ASCII-first: non-ASCII characters will be replaced with '?'.
 * - Good enough for "generate a PDF artifact" without introducing new dependencies.
 */
internal class TinyPdfWriter(
    private val pageWidth: Int = 595,   // A4 width in points
    private val pageHeight: Int = 842,  // A4 height in points
    private val marginLeft: Int = 50,
    private val marginTop: Int = 60,
    private val fontSize: Int = 11,
    private val leading: Int = 14,
    private val approxCharsPerLine: Int = 95
) {

    fun write(title: String, markdown: String, outFile: Path) {
        Files.createDirectories(outFile.parent)

        val plain = markdownToPlainText(markdown)
        val lines = wrapLines(plain, approxCharsPerLine)

        val linesPerPage = ((pageHeight - marginTop - 60) / leading).coerceAtLeast(20)
        val pages: List<List<String>> = lines.chunked(linesPerPage)

        val pdfBytes = buildPdf(title, pages)
        Files.write(outFile, pdfBytes)
    }

    private fun markdownToPlainText(md: String): String {
        // Very lightweight "de-markdown".
        // Keep headings and bullets readable.
        val s = md
            .replace("\r\n", "\n")
            .replace(Regex("""^#{1,6}\s*""", RegexOption.MULTILINE), "") // remove heading hashes
            .replace("**", "")
            .replace("*", "")
            .replace("`", "")
        return s
    }

    private fun wrapLines(text: String, width: Int): List<String> {
        val out = mutableListOf<String>()
        for (raw in text.split('\n')) {
            var line = raw.trimEnd()
            if (line.isBlank()) {
                out += ""
                continue
            }
            while (line.length > width) {
                // Prefer breaking on spaces.
                val cut = line.lastIndexOf(' ', startIndex = width).takeIf { it >= width / 2 } ?: width
                out += line.substring(0, cut).trimEnd()
                line = line.substring(cut).trimStart()
            }
            out += line
        }
        return out
    }

    private fun buildPdf(title: String, pages: List<List<String>>): ByteArray {
        // Fixed object numbers:
        // 1: Catalog
        // 2: Pages
        // 3: Font
        // For each page i (1-based):
        //  content obj = 4 + (i-1)*2
        //  page obj    = 5 + (i-1)*2
        val numPages = pages.size.coerceAtLeast(1)

        val objects = mutableListOf<String>()

        // 1) Catalog
        objects += "<< /Type /Catalog /Pages 2 0 R >>"

        // 2) Pages (Kids will reference each page object)
        val kids = (1..numPages).joinToString(" ") { i ->
            val pageObjNum = 5 + (i - 1) * 2
            "$pageObjNum 0 R"
        }
        objects += "<< /Type /Pages /Kids [ $kids ] /Count $numPages >>"

        // 3) Font
        objects += "<< /Type /Font /Subtype /Type1 /BaseFont /Helvetica >>"

        // Page content + page objects
        for ((idx, pageLines) in pages.withIndex()) {
            val pageIndex = idx + 1
            val contentObjNum = 4 + (pageIndex - 1) * 2
            val pageObjNum = contentObjNum + 1

            val contentStream = buildPageContentStream(title, pageIndex, numPages, pageLines)
            val contentBytes = contentStream.toByteArray(StandardCharsets.US_ASCII)
            val contentObj =
                "<< /Length ${contentBytes.size} >>\nstream\n$contentStream\nendstream"
            objects += contentObj

            val pageObj =
                """
<< /Type /Page
   /Parent 2 0 R
   /MediaBox [0 0 $pageWidth $pageHeight]
   /Resources << /Font << /F1 3 0 R >> >>
   /Contents $contentObjNum 0 R
>>
                """.trimIndent()
            objects += pageObj
        }

        return assemblePdf(objects)
    }

    private fun buildPageContentStream(
        title: String,
        pageIndex: Int,
        totalPages: Int,
        lines: List<String>
    ): String {
        val safeTitle = sanitizeAscii(title)
        val header = "$safeTitle  (Page $pageIndex/$totalPages)"

        val startX = marginLeft
        val startY = pageHeight - marginTop

        return buildString {
            appendLine("BT")
            appendLine("/F1 $fontSize Tf")
            appendLine("$startX $startY Td")
            appendLine("$leading TL")

            // Header
            appendLine("(${escapePdfString(header)}) Tj")
            appendLine("T*")
            appendLine("T*")

            for (line in lines) {
                val safe = sanitizeAscii(line)
                appendLine("(${escapePdfString(safe)}) Tj")
                appendLine("T*")
            }
            appendLine("ET")
        }.trimEnd()
    }

    private fun sanitizeAscii(s: String): String {
        val sb = StringBuilder(s.length)
        for (ch in s) {
            sb.append(if (ch.code in 32..126) ch else '?')
        }
        return sb.toString()
    }

    private fun escapePdfString(s: String): String {
        // Escape backslash and parentheses for PDF literal strings.
        return s
            .replace("\\", "\\\\")
            .replace("(", "\\(")
            .replace(")", "\\)")
    }

    private fun assemblePdf(objects: List<String>): ByteArray {
        val out = ByteArrayOutputStream()
        fun w(str: String) = out.write(str.toByteArray(StandardCharsets.US_ASCII))

        w("%PDF-1.4\n")
        w("%\u00E2\u00E3\u00CF\u00D3\n") // binary comment

        val offsets = IntArray(objects.size + 1)
        offsets[0] = 0

        for (i in objects.indices) {
            offsets[i + 1] = out.size()
            w("${i + 1} 0 obj\n")
            w(objects[i])
            w("\nendobj\n")
        }

        val xrefPos = out.size()
        w("xref\n")
        w("0 ${objects.size + 1}\n")
        w("0000000000 65535 f \n")
        for (i in 1..objects.size) {
            val off = offsets[i]
            w(String.format("%010d 00000 n \n", off))
        }

        w("trailer\n")
        w("<< /Size ${objects.size + 1} /Root 1 0 R >>\n")
        w("startxref\n")
        w("$xrefPos\n")
        w("%%EOF\n")

        return out.toByteArray()
    }
}