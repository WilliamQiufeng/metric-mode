package org.example.app.result

import ai.koog.prompt.dsl.prompt
import ai.koog.prompt.executor.clients.openai.OpenAIModels
import ai.koog.prompt.executor.model.PromptExecutor
import ai.koog.prompt.structure.StructureFixingParser
import ai.koog.prompt.structure.executeStructured
import kotlinx.serialization.Serializable
import kotlinx.serialization.json.JsonObject
import org.example.app.core.MlAutoGenCore
import java.io.ByteArrayOutputStream
import java.nio.charset.StandardCharsets
import java.nio.file.Files
import java.nio.file.Path
import kotlin.io.path.exists
import kotlin.io.path.readText
import kotlin.io.path.writeText

/**
 * report.kt
 *
 * Generates a detailed report based on:
 * - model.py
 * - Pipeline artifacts from the latest workflow (if present):
 *     * tune_result.json, best_params.json
 *     * final_train_result.json, trained_model.json
 *     * prediction_result.json, predictions.csv
 * - Optional final_test output (stdout + optional JSON) if you still run a separate final_test.py stage.
 *
 * Outputs:
 * - workDir/report.md
 * - workDir/report.pdf  (generated by a tiny, dependency-free PDF writer)
 *
 * Note:
 * - The tiny PDF writer is ASCII-first; it will replace non-ASCII chars with '?'.
 * - Therefore the LLM is instructed to write the report in English by default.
 */
class ReportGenerator(
    private val executor: PromptExecutor,
    private val llmModel: ai.koog.prompt.llm.LLModel = OpenAIModels.Chat.GPT4oMini,
    private val fixerModel: ai.koog.prompt.llm.LLModel = OpenAIModels.Chat.GPT4o
) {

    @Serializable
    data class ReportDoc(
        val title: String,
        val executiveSummary: String,
        val taskSpec: String,
        val modelOverview: String,
        val dataPipeline: String,
        val trainingAndInference: String,
        val evaluation: String,
        val metrics: List<MetricItem>,
        val interpretability: String,
        val failureModesAndLimitations: List<String>,
        val recommendedNextSteps: List<String>,
        val reproducibility: List<String>,
        val appendixNotes: String
    ) {
        @Serializable
        data class MetricItem(
            val name: String,
            val value: String,
            val notes: String
        )
    }

    data class ReportArtifacts(
        val markdownPath: Path,
        val pdfPath: Path
    )

    /**
     * Legacy entry-point for the older "final_test"-centric workflow.
     * Kept to avoid breaking older callers; internally routes to generatePipelineReport(...).
     */
    @Deprecated("Use generatePipelineReport(...) for the tune/final_train/prediction workflow")
    suspend fun generate(
        workDir: Path,
        spec: MlAutoGenCore.ChecklistSpec,
        finalTestStdout: String,
        finalTestJson: JsonObject? = null,
        contract: String = MlAutoGenCore.MODEL_API_CONTRACT,
        outMarkdown: String = "report.md",
        outPdf: String = "report.pdf"
    ): ReportArtifacts = generatePipelineReport(
        workDir = workDir,
        spec = spec,
        tuneStdout = null,
        tuneJson = null,
        finalTrainStdout = null,
        finalTrainJson = null,
        predictionStdout = null,
        predictionJson = null,
        finalTestStdout = finalTestStdout,
        finalTestJson = finalTestJson,
        contract = contract,
        outMarkdown = outMarkdown,
        outPdf = outPdf
    )

    /**
     * New entry-point: report for the tune -> final_train -> prediction pipeline.
     *
     * You can pass stdout/JSON from each stage if you have them in memory; otherwise this will
     * try to read the standard artifacts from workDir for grounding.
     */
    suspend fun generatePipelineReport(
        workDir: Path,
        spec: MlAutoGenCore.ChecklistSpec,
        tuneStdout: String? = null,
        tuneJson: JsonObject? = null,
        finalTrainStdout: String? = null,
        finalTrainJson: JsonObject? = null,
        predictionStdout: String? = null,
        predictionJson: JsonObject? = null,
        finalTestStdout: String? = null,
        finalTestJson: JsonObject? = null,
        contract: String = MlAutoGenCore.MODEL_API_CONTRACT,
        outMarkdown: String = "report.md",
        outPdf: String = "report.pdf"
    ): ReportArtifacts {
        val modelPath = workDir.resolve("model.py")
        require(modelPath.exists()) { "model.py not found at: $modelPath" }

        val modelPy = modelPath.readText()
        val modelPreview = ResultIo.truncateForPrompt(
            ResultIo.smartPreview(modelPy, headChars = 6000, tailChars = 2500),
            maxChars = 9000
        )

        // Try to ground the report in on-disk artifacts, even if caller doesn't provide stdout/json.
        val tuneResultPreview = readTextPreviewIfExists(workDir.resolve("tune_result.json"), 2500)
        val bestParamsPreview = readTextPreviewIfExists(workDir.resolve("best_params.json"), 2500)
        val finalTrainResultPreview = readTextPreviewIfExists(workDir.resolve("final_train_result.json"), 2500)
        val trainedModelPreview = readTextPreviewIfExists(workDir.resolve("trained_model.json"), 1800)
        val predictionResultPreview = readTextPreviewIfExists(workDir.resolve("prediction_result.json"), 2500)
        val predictionsCsvPreview = readLinesPreviewIfExists(workDir.resolve("predictions.csv"), maxLines = 25, maxChars = 4000)

        val fixingParser = StructureFixingParser(model = fixerModel, retries = 2)

        val p = prompt("generate-detailed-report-v2") {
            system(
                """
You are a senior ML engineer writing a detailed technical report for stakeholders.

The system runs a multi-stage pipeline:
1) tune.py: train/val split and hyperparameter selection -> best_params.json + tune_result.json
2) final_train.py: train final model on all labeled data using best_params -> trained_model.json + final_train_result.json
3) predict.py: run inference on a separate prediction dataset -> predictions.csv + prediction_result.json

Output ONLY valid JSON following the schema ReportDoc.
No markdown fences. No extra commentary.

Constraints:
- Be consistent with the given task spec + contract + model.py preview.
- Ground evaluation/metrics in tune_result (VAL metric) and/or final_test output (if provided).
- If some artifacts are missing, explicitly say which ones are missing and what the pipeline can/cannot guarantee.
- Keep it detailed but not overly long.
- Write in English (PDF writer is ASCII-first).
                """.trimIndent()
            )
            user(
                """
Task spec:
- inputType = ${spec.inputType}
- outputType = ${spec.outputType}
- trainingType = ${spec.trainingType}
- splitStrategy = ${spec.splitStrategy}
- metric = ${spec.metric}
- dataPath = ${spec.dataPath}

Model API contract:
$contract

model.py preview (may be truncated):
$modelPreview

---
Tune stage (optional in-memory stdout):
${tuneStdout?.let { ResultIo.truncateForPrompt(it, 6000) } ?: "null"}

Tune stage JSON (optional):
${tuneJson?.toString() ?: "null"}

tune_result.json preview (if exists):
${tuneResultPreview ?: "(missing)"}

best_params.json preview (if exists):
${bestParamsPreview ?: "(missing)"}

---
Final-train stage (optional in-memory stdout):
${finalTrainStdout?.let { ResultIo.truncateForPrompt(it, 6000) } ?: "null"}

Final-train stage JSON (optional):
${finalTrainJson?.toString() ?: "null"}

final_train_result.json preview (if exists):
${finalTrainResultPreview ?: "(missing)"}

trained_model.json preview (if exists; may be large/truncated):
${trainedModelPreview ?: "(missing)"}

---
Prediction stage (optional in-memory stdout):
${predictionStdout?.let { ResultIo.truncateForPrompt(it, 6000) } ?: "null"}

Prediction stage JSON (optional):
${predictionJson?.toString() ?: "null"}

prediction_result.json preview (if exists):
${predictionResultPreview ?: "(missing)"}

predictions.csv preview (first lines if exists):
${predictionsCsvPreview ?: "(missing)"}

---
Legacy final_test stdout (optional):
${finalTestStdout?.let { ResultIo.truncateForPrompt(it, 6000) } ?: "null"}

Legacy final_test JSON (optional):
${finalTestJson?.toString() ?: "null"}
                """.trimIndent()
            )
        }

        val report = executor.executeStructured<ReportDoc>(
            prompt = p,
            model = llmModel,
            fixingParser = fixingParser
        ).getOrThrow().data

        val md = renderMarkdown(report)
        val mdPath = workDir.resolve(outMarkdown)
        mdPath.writeText(md)

        val pdfPath = workDir.resolve(outPdf)
        TinyPdfWriter().write(
            title = report.title,
            markdown = md,
            outFile = pdfPath
        )

        return ReportArtifacts(markdownPath = mdPath, pdfPath = pdfPath)
    }

    private fun readTextPreviewIfExists(path: Path, maxChars: Int): String? {
        if (!path.exists()) return null
        val txt = runCatching { path.readText() }.getOrNull() ?: return null
        return ResultIo.truncateForPrompt(txt, maxChars)
    }

    private fun readLinesPreviewIfExists(path: Path, maxLines: Int, maxChars: Int): String? {
        if (!path.exists()) return null
        val txt = runCatching {
            path.readText().lineSequence().take(maxLines).joinToString("\n")
        }.getOrNull() ?: return null
        return ResultIo.truncateForPrompt(txt, maxChars)
    }

    private fun renderMarkdown(doc: ReportDoc): String = buildString {
        appendLine("# ${doc.title}".trim())
        appendLine()
        appendLine("## Executive summary")
        appendLine(doc.executiveSummary.trim())
        appendLine()
        appendLine("## Task specification")
        appendLine(doc.taskSpec.trim())
        appendLine()
        appendLine("## Model overview")
        appendLine(doc.modelOverview.trim())
        appendLine()
        appendLine("## Data pipeline")
        appendLine(doc.dataPipeline.trim())
        appendLine()
        appendLine("## Training and inference")
        appendLine(doc.trainingAndInference.trim())
        appendLine()
        appendLine("## Evaluation")
        appendLine(doc.evaluation.trim())
        appendLine()
        appendLine("## Metrics")
        if (doc.metrics.isEmpty()) {
            appendLine("- (No metrics reported)")
        } else {
            doc.metrics.forEach {
                appendLine("- **${it.name}**: ${it.value} â€” ${it.notes}".trim())
            }
        }
        appendLine()
        appendLine("## Interpretability and model expression")
        appendLine(doc.interpretability.trim())
        appendLine()
        appendLine("## Failure modes and limitations")
        doc.failureModesAndLimitations.forEach { appendLine("- ${it.trim()}") }
        appendLine()
        appendLine("## Recommended next steps")
        doc.recommendedNextSteps.forEach { appendLine("- ${it.trim()}") }
        appendLine()
        appendLine("## Reproducibility checklist")
        doc.reproducibility.forEach { appendLine("- ${it.trim()}") }
        appendLine()
        appendLine("## Appendix")
        appendLine(doc.appendixNotes.trim())
        appendLine()
    }
}

/**
 * A tiny, dependency-free PDF writer.
 *
 * - Creates a simple multi-page PDF with Helvetica Type1 font.
 * - ASCII-first: non-ASCII characters will be replaced with '?'.
 * - Good enough for "generate a PDF artifact" without introducing new dependencies.
 */
internal class TinyPdfWriter(
    private val pageWidth: Int = 595,   // A4 width in points
    private val pageHeight: Int = 842,  // A4 height in points
    private val marginLeft: Int = 50,
    private val marginTop: Int = 60,
    private val fontSize: Int = 11,
    private val leading: Int = 14,
    private val approxCharsPerLine: Int = 95
) {

    fun write(title: String, markdown: String, outFile: Path) {
        Files.createDirectories(outFile.parent)

        val plain = markdownToPlainText(markdown)
        val lines = wrapLines(plain, approxCharsPerLine)

        val linesPerPage = ((pageHeight - marginTop - 60) / leading).coerceAtLeast(20)
        val pages: List<List<String>> = lines.chunked(linesPerPage)

        val pdfBytes = buildPdf(title, pages)
        Files.write(outFile, pdfBytes)
    }

    private fun markdownToPlainText(md: String): String {
        // Very lightweight "de-markdown".
        // Keep headings and bullets readable.
        val s = md
            .replace("\r\n", "\n")
            .replace(Regex("""^#{1,6}\s*""", RegexOption.MULTILINE), "") // remove heading hashes
            .replace("**", "")
            .replace("*", "")
            .replace("`", "")
        return s
    }

    private fun wrapLines(text: String, width: Int): List<String> {
        val out = mutableListOf<String>()
        for (raw in text.split('\n')) {
            var line = raw.trimEnd()
            if (line.isBlank()) {
                out += ""
                continue
            }
            while (line.length > width) {
                // Prefer breaking on spaces.
                val cut = line.lastIndexOf(' ', startIndex = width).takeIf { it >= width / 2 } ?: width
                out += line.substring(0, cut).trimEnd()
                line = line.substring(cut).trimStart()
            }
            out += line
        }
        return out
    }

    private fun buildPdf(title: String, pages: List<List<String>>): ByteArray {
        // Fixed object numbers:
        // 1: Catalog
        // 2: Pages
        // 3: Font
        // For each page i (1-based):
        //  content obj = 4 + (i-1)*2
        //  page obj    = 5 + (i-1)*2
        val numPages = pages.size.coerceAtLeast(1)

        val objects = mutableListOf<String>()

        // 1) Catalog
        objects += "<< /Type /Catalog /Pages 2 0 R >>"

        // 2) Pages (Kids will reference each page object)
        val kids = (1..numPages).joinToString(" ") { i ->
            val pageObjNum = 5 + (i - 1) * 2
            "$pageObjNum 0 R"
        }
        objects += "<< /Type /Pages /Kids [ $kids ] /Count $numPages >>"

        // 3) Font
        objects += "<< /Type /Font /Subtype /Type1 /BaseFont /Helvetica >>"

        // Page content + page objects
        for ((idx, pageLines) in pages.withIndex()) {
            val pageIndex = idx + 1
            val contentObjNum = 4 + (pageIndex - 1) * 2
            val pageObjNum = contentObjNum + 1

            val contentStream = buildPageContentStream(title, pageIndex, numPages, pageLines)
            val contentBytes = contentStream.toByteArray(StandardCharsets.US_ASCII)
            val contentObj =
                "<< /Length ${contentBytes.size} >>\nstream\n$contentStream\nendstream"
            objects += contentObj

            val pageObj =
                """
<< /Type /Page
   /Parent 2 0 R
   /MediaBox [0 0 $pageWidth $pageHeight]
   /Resources << /Font << /F1 3 0 R >> >>
   /Contents $contentObjNum 0 R
>>
                """.trimIndent()
            objects += pageObj
        }

        return assemblePdf(objects)
    }

    private fun buildPageContentStream(
        title: String,
        pageIndex: Int,
        totalPages: Int,
        lines: List<String>
    ): String {
        val safeTitle = sanitizeAscii(title)
        val header = "$safeTitle  (Page $pageIndex/$totalPages)"

        val startX = marginLeft
        val startY = pageHeight - marginTop

        return buildString {
            appendLine("BT")
            appendLine("/F1 $fontSize Tf")
            appendLine("$startX $startY Td")
            appendLine("$leading TL")

            // Header
            appendLine("(${escapePdfString(header)}) Tj")
            appendLine("T*")
            appendLine("T*")

            for (line in lines) {
                val safe = sanitizeAscii(line)
                appendLine("(${escapePdfString(safe)}) Tj")
                appendLine("T*")
            }
            appendLine("ET")
        }.trimEnd()
    }

    private fun sanitizeAscii(s: String): String {
        val sb = StringBuilder(s.length)
        for (ch in s) {
            sb.append(if (ch.code in 32..126) ch else '?')
        }
        return sb.toString()
    }

    private fun escapePdfString(s: String): String {
        // Escape backslash and parentheses for PDF literal strings.
        return s
            .replace("\\", "\\\\")
            .replace("(", "\\(")
            .replace(")", "\\)")
    }

    private fun assemblePdf(objects: List<String>): ByteArray {
        val out = ByteArrayOutputStream()
        fun w(str: String) = out.write(str.toByteArray(StandardCharsets.US_ASCII))

        w("%PDF-1.4\n")
        w("%\u00E2\u00E3\u00CF\u00D3\n") // binary comment

        val offsets = IntArray(objects.size + 1)
        offsets[0] = 0

        for (i in objects.indices) {
            offsets[i + 1] = out.size()
            w("${i + 1} 0 obj\n")
            w(objects[i])
            w("\nendobj\n")
        }

        val xrefPos = out.size()
        w("xref\n")
        w("0 ${objects.size + 1}\n")
        w("0000000000 65535 f \n")
        for (i in 1..objects.size) {
            val off = offsets[i]
            w(String.format("%010d 00000 n \n", off))
        }

        w("trailer\n")
        w("<< /Size ${objects.size + 1} /Root 1 0 R >>\n")
        w("startxref\n")
        w("$xrefPos\n")
        w("%%EOF\n")

        return out.toByteArray()
    }
}